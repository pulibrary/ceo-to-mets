From d30c82f10145f8c1c05ecba26318b1005dc01d12 Mon Sep 17 00:00:00 2001
From: Cliff Wulfman <cwulfman@princeton.edu>
Date: Thu, 30 Oct 2025 12:20:32 +0000
Subject: [PATCH 2/3] Add ALTO XML generator for PDF layout extraction
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Implement ALTOGenerator to create ALTO v4.4 XML from PDFs:
- Uses PyMuPDF (fitz) to extract text with coordinate information
- Generates ALTO-compliant XML with page layout structure
- Includes dataclasses for ALTO structure (ALTOString, ALTOTextLine, ALTOTextBlock, ALTOPage)
- Comprehensive test suite with 18 tests
- Adds PyMuPDF dependency to pyproject.toml
- Updates generators __init__.py to export ALTOGenerator

ALTO (Analyzed Layout and Text Object) format is designed for
OCR workflows but is generated here from PDFs to provide coordinate
information for text layout.

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
Co-authored-by: Sculptor <sculptor@imbue.com>
---
 pyproject.toml                   |   1 +
 src/generators/__init__.py       |   3 +-
 src/generators/alto_generator.py | 301 +++++++++++++++++++++++++++++++
 tests/test_alto_generator.py     | 289 +++++++++++++++++++++++++++++
 4 files changed, 593 insertions(+), 1 deletion(-)
 create mode 100644 src/generators/alto_generator.py
 create mode 100644 tests/test_alto_generator.py

diff --git a/pyproject.toml b/pyproject.toml
index fc8ab0c..2ca6f41 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -11,6 +11,7 @@ dependencies = [
     "lxml>=5.0.0",
     "jinja2>=3.1.0",
     "html2text>=2020.1.16",
+    "pymupdf>=1.24.0",
 ]
 requires-python = ">=3.12"
 readme = "README.md"
diff --git a/src/generators/__init__.py b/src/generators/__init__.py
index 112a9c4..baf96c6 100644
--- a/src/generators/__init__.py
+++ b/src/generators/__init__.py
@@ -2,5 +2,6 @@ from .html_generator import HTMLGenerator
 from .pdf_generator import PDFGenerator
 from .txt_generator import TXTGenerator
 from .mods_generator import MODSGenerator
+from .alto_generator import ALTOGenerator
 
-__all__ = ["HTMLGenerator", "PDFGenerator", "TXTGenerator", "MODSGenerator"]
+__all__ = ["HTMLGenerator", "PDFGenerator", "TXTGenerator", "MODSGenerator", "ALTOGenerator"]
diff --git a/src/generators/alto_generator.py b/src/generators/alto_generator.py
new file mode 100644
index 0000000..b42a817
--- /dev/null
+++ b/src/generators/alto_generator.py
@@ -0,0 +1,301 @@
+"""
+ALTO XML Generator for Daily Princetonian Articles
+
+This module generates ALTO (Analyzed Layout and Text Object) XML files from PDF documents.
+ALTO v4.4 format is used to describe the layout and text content with coordinate information.
+"""
+
+from pathlib import Path
+from typing import List, Optional, Union
+from dataclasses import dataclass
+from lxml import etree
+import fitz  # PyMuPDF
+
+
+@dataclass
+class ALTOString:
+    """Represents a word/string in ALTO format with coordinates."""
+    content: str
+    hpos: float
+    vpos: float
+    width: float
+    height: float
+    wc: float = 1.0  # Word confidence (0.0-1.0)
+
+
+@dataclass
+class ALTOTextLine:
+    """Represents a line of text in ALTO format."""
+    strings: List[ALTOString]
+    hpos: float
+    vpos: float
+    width: float
+    height: float
+
+
+@dataclass
+class ALTOTextBlock:
+    """Represents a block of text (e.g., paragraph) in ALTO format."""
+    lines: List[ALTOTextLine]
+    hpos: float
+    vpos: float
+    width: float
+    height: float
+    block_type: str = "paragraph"
+
+
+@dataclass
+class ALTOPage:
+    """Represents a page in ALTO format."""
+    page_number: int
+    width: float
+    height: float
+    blocks: List[ALTOTextBlock]
+
+
+class ALTOGenerator:
+    """
+    Generate ALTO XML from PDF files.
+
+    ALTO (Analyzed Layout and Text Object) is an XML schema for describing
+    layout and content of scanned documents. While typically used for OCR
+    workflows, we generate ALTO from PDFs to provide coordinate information
+    for text layout.
+
+    This implementation uses PyMuPDF to extract text with coordinates from PDFs
+    and structures it according to ALTO v4.4 specifications.
+    """
+
+    ALTO_NAMESPACE = "http://www.loc.gov/standards/alto/ns-v4#"
+    ALTO_VERSION = "4.4"
+
+    def __init__(self, pdf_path: Union[str, Path], article_item=None):
+        """
+        Initialize ALTO generator.
+
+        Args:
+            pdf_path: Path to the PDF file to process
+            article_item: Optional CeoItem with article metadata
+        """
+        self.pdf_path = Path(pdf_path)
+        self.article_item = article_item
+
+        if not self.pdf_path.exists():
+            raise FileNotFoundError(f"PDF file not found: {self.pdf_path}")
+
+    def extract_layout_from_pdf(self) -> List[ALTOPage]:
+        """
+        Extract text layout information from PDF using PyMuPDF.
+
+        Returns:
+            List of ALTOPage objects containing layout information
+        """
+        pages = []
+
+        with fitz.open(self.pdf_path) as pdf_doc:
+            for page_num in range(len(pdf_doc)):
+                page = pdf_doc[page_num]
+                page_width = page.rect.width
+                page_height = page.rect.height
+
+                blocks = []
+
+                # Extract text with detailed layout information
+                text_dict = page.get_text("dict")
+
+                for block in text_dict.get("blocks", []):
+                    if block.get("type") != 0:  # Skip non-text blocks
+                        continue
+
+                    lines = []
+                    block_bbox = block.get("bbox", [0, 0, 0, 0])
+
+                    for line in block.get("lines", []):
+                        strings = []
+                        line_bbox = line.get("bbox", [0, 0, 0, 0])
+
+                        for span in line.get("spans", []):
+                            text = span.get("text", "").strip()
+                            if not text:
+                                continue
+
+                            bbox = span.get("bbox", [0, 0, 0, 0])
+
+                            alto_string = ALTOString(
+                                content=text,
+                                hpos=bbox[0],
+                                vpos=bbox[1],
+                                width=bbox[2] - bbox[0],
+                                height=bbox[3] - bbox[1],
+                                wc=1.0
+                            )
+                            strings.append(alto_string)
+
+                        if strings:
+                            alto_line = ALTOTextLine(
+                                strings=strings,
+                                hpos=line_bbox[0],
+                                vpos=line_bbox[1],
+                                width=line_bbox[2] - line_bbox[0],
+                                height=line_bbox[3] - line_bbox[1]
+                            )
+                            lines.append(alto_line)
+
+                    if lines:
+                        alto_block = ALTOTextBlock(
+                            lines=lines,
+                            hpos=block_bbox[0],
+                            vpos=block_bbox[1],
+                            width=block_bbox[2] - block_bbox[0],
+                            height=block_bbox[3] - block_bbox[1],
+                            block_type="paragraph"
+                        )
+                        blocks.append(alto_block)
+
+                alto_page = ALTOPage(
+                    page_number=page_num + 1,
+                    width=page_width,
+                    height=page_height,
+                    blocks=blocks
+                )
+                pages.append(alto_page)
+
+        return pages
+
+    def generate_alto_xml(self) -> etree.Element:
+        """
+        Generate ALTO v4.4 XML structure.
+
+        Returns:
+            lxml Element containing the complete ALTO XML structure
+        """
+        pages = self.extract_layout_from_pdf()
+
+        nsmap = {None: self.ALTO_NAMESPACE}
+
+        # Root element
+        alto = etree.Element(
+            "alto",
+            nsmap=nsmap,
+            attrib={
+                "xmlns": self.ALTO_NAMESPACE,
+                "{http://www.w3.org/2001/XMLSchema-instance}schemaLocation":
+                    f"{self.ALTO_NAMESPACE} "
+                    "http://www.loc.gov/standards/alto/v4/alto-4-4.xsd"
+            }
+        )
+
+        # Description section
+        description = etree.SubElement(alto, "Description")
+
+        measurement_unit = etree.SubElement(description, "MeasurementUnit")
+        measurement_unit.text = "pixel"
+
+        source_image_info = etree.SubElement(description, "sourceImageInformation")
+        file_name = etree.SubElement(source_image_info, "fileName")
+        file_name.text = self.pdf_path.name
+
+        # Processing software info
+        processing = etree.SubElement(description, "Processing")
+        processing.set("ID", "PROC1")
+
+        processing_software = etree.SubElement(processing, "processingSoftware")
+        software_creator = etree.SubElement(processing_software, "softwareCreator")
+        software_creator.text = "Daily Princetonian METS Generator"
+
+        software_name = etree.SubElement(processing_software, "softwareName")
+        software_name.text = "ALTOGenerator"
+
+        software_version = etree.SubElement(processing_software, "softwareVersion")
+        software_version.text = "1.0"
+
+        # Layout section
+        layout = etree.SubElement(alto, "Layout")
+
+        for alto_page in pages:
+            page_elem = etree.SubElement(
+                layout, "Page",
+                ID=f"PAGE_{alto_page.page_number}",
+                PHYSICAL_IMG_NR=str(alto_page.page_number),
+                HEIGHT=f"{alto_page.height:.2f}",
+                WIDTH=f"{alto_page.width:.2f}"
+            )
+
+            print_space = etree.SubElement(
+                page_elem, "PrintSpace",
+                HPOS="0",
+                VPOS="0",
+                HEIGHT=f"{alto_page.height:.2f}",
+                WIDTH=f"{alto_page.width:.2f}"
+            )
+
+            for block_idx, block in enumerate(alto_page.blocks, 1):
+                text_block = etree.SubElement(
+                    print_space, "TextBlock",
+                    ID=f"TB_{alto_page.page_number}_{block_idx}",
+                    HPOS=f"{block.hpos:.2f}",
+                    VPOS=f"{block.vpos:.2f}",
+                    HEIGHT=f"{block.height:.2f}",
+                    WIDTH=f"{block.width:.2f}"
+                )
+
+                for line_idx, line in enumerate(block.lines, 1):
+                    text_line = etree.SubElement(
+                        text_block, "TextLine",
+                        ID=f"TL_{alto_page.page_number}_{block_idx}_{line_idx}",
+                        HPOS=f"{line.hpos:.2f}",
+                        VPOS=f"{line.vpos:.2f}",
+                        HEIGHT=f"{line.height:.2f}",
+                        WIDTH=f"{line.width:.2f}"
+                    )
+
+                    for string_idx, string in enumerate(line.strings, 1):
+                        string_elem = etree.SubElement(
+                            text_line, "String",
+                            ID=f"S_{alto_page.page_number}_{block_idx}_{line_idx}_{string_idx}",
+                            CONTENT=string.content,
+                            HPOS=f"{string.hpos:.2f}",
+                            VPOS=f"{string.vpos:.2f}",
+                            HEIGHT=f"{string.height:.2f}",
+                            WIDTH=f"{string.width:.2f}",
+                            WC=f"{string.wc:.2f}"
+                        )
+
+        return alto
+
+    def to_string(self, pretty_print: bool = True) -> str:
+        """
+        Generate ALTO XML as a string.
+
+        Args:
+            pretty_print: Whether to format the XML with indentation
+
+        Returns:
+            ALTO XML as a UTF-8 string
+        """
+        alto_xml = self.generate_alto_xml()
+        return etree.tostring(
+            alto_xml,
+            pretty_print=pretty_print,
+            encoding='unicode',
+            xml_declaration=False
+        )
+
+    def generate(self, output_path: Union[str, Path]) -> None:
+        """
+        Generate and save ALTO XML to a file.
+
+        Args:
+            output_path: Path where the ALTO XML file will be saved
+        """
+        output_path = Path(output_path)
+        output_path.parent.mkdir(parents=True, exist_ok=True)
+
+        alto_xml = self.generate_alto_xml()
+        tree = etree.ElementTree(alto_xml)
+        tree.write(
+            str(output_path),
+            pretty_print=True,
+            xml_declaration=True,
+            encoding='UTF-8'
+        )
diff --git a/tests/test_alto_generator.py b/tests/test_alto_generator.py
new file mode 100644
index 0000000..59668c7
--- /dev/null
+++ b/tests/test_alto_generator.py
@@ -0,0 +1,289 @@
+"""Tests for ALTO XML generator."""
+
+import pytest
+from pathlib import Path
+from lxml import etree
+
+from generators.alto_generator import (
+    ALTOGenerator,
+    ALTOString,
+    ALTOTextLine,
+    ALTOTextBlock,
+    ALTOPage
+)
+from generators.html_generator import HTMLGenerator
+from generators.pdf_generator import PDFGenerator
+
+
+class TestALTODataclasses:
+    """Test ALTO dataclass structures."""
+
+    def test_alto_string_creation(self):
+        """Test creating an ALTOString."""
+        string = ALTOString(
+            content="Hello",
+            hpos=10.0,
+            vpos=20.0,
+            width=50.0,
+            height=12.0,
+            wc=0.95
+        )
+        assert string.content == "Hello"
+        assert string.hpos == 10.0
+        assert string.wc == 0.95
+
+    def test_alto_string_default_confidence(self):
+        """Test ALTOString default confidence value."""
+        string = ALTOString(
+            content="Test",
+            hpos=0.0,
+            vpos=0.0,
+            width=10.0,
+            height=10.0
+        )
+        assert string.wc == 1.0
+
+    def test_alto_text_line_creation(self):
+        """Test creating an ALTOTextLine."""
+        strings = [
+            ALTOString("Hello", 10.0, 20.0, 30.0, 10.0),
+            ALTOString("World", 45.0, 20.0, 35.0, 10.0)
+        ]
+        line = ALTOTextLine(strings, 10.0, 20.0, 70.0, 10.0)
+        assert len(line.strings) == 2
+        assert line.width == 70.0
+
+    def test_alto_text_block_creation(self):
+        """Test creating an ALTOTextBlock."""
+        strings = [ALTOString("Test", 10.0, 20.0, 30.0, 10.0)]
+        lines = [ALTOTextLine(strings, 10.0, 20.0, 30.0, 10.0)]
+        block = ALTOTextBlock(lines, 10.0, 20.0, 30.0, 20.0)
+        assert len(block.lines) == 1
+        assert block.block_type == "paragraph"
+
+    def test_alto_page_creation(self):
+        """Test creating an ALTOPage."""
+        page = ALTOPage(
+            page_number=1,
+            width=612.0,
+            height=792.0,
+            blocks=[]
+        )
+        assert page.page_number == 1
+        assert page.width == 612.0
+        assert len(page.blocks) == 0
+
+
+class TestALTOGenerator:
+    """Test ALTOGenerator functionality."""
+
+    def test_alto_generator_init(self, sample_ceo_item, tmp_path):
+        """Test initializing ALTOGenerator."""
+        # Create a PDF first
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        # Now create ALTO generator
+        generator = ALTOGenerator(pdf_path, sample_ceo_item)
+        assert generator.pdf_path == pdf_path
+        assert generator.article_item == sample_ceo_item
+
+    def test_alto_generator_file_not_found(self):
+        """Test ALTOGenerator raises error for missing PDF."""
+        with pytest.raises(FileNotFoundError):
+            ALTOGenerator("/nonexistent/file.pdf")
+
+    def test_extract_layout_from_pdf(self, sample_ceo_item, tmp_path):
+        """Test extracting layout from PDF."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        pages = generator.extract_layout_from_pdf()
+
+        assert len(pages) > 0
+        assert isinstance(pages[0], ALTOPage)
+        assert pages[0].page_number == 1
+        assert pages[0].width > 0
+        assert pages[0].height > 0
+
+    def test_extract_layout_has_blocks(self, sample_ceo_item, tmp_path):
+        """Test that extracted layout contains text blocks."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        pages = generator.extract_layout_from_pdf()
+
+        # Should have at least one page with blocks
+        assert len(pages) > 0
+        # May have blocks depending on PDF content
+        if pages[0].blocks:
+            assert isinstance(pages[0].blocks[0], ALTOTextBlock)
+
+    def test_generate_alto_xml(self, sample_ceo_item, tmp_path):
+        """Test generating ALTO XML structure."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        alto_xml = generator.generate_alto_xml()
+
+        assert alto_xml is not None
+        assert alto_xml.tag == "{http://www.loc.gov/standards/alto/ns-v4#}alto"
+
+    def test_alto_xml_has_description(self, sample_ceo_item, tmp_path):
+        """Test ALTO XML contains Description section."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        alto_xml = generator.generate_alto_xml()
+
+        namespaces = {'alto': ALTOGenerator.ALTO_NAMESPACE}
+        description = alto_xml.find('alto:Description', namespaces)
+        assert description is not None
+
+    def test_alto_xml_has_layout(self, sample_ceo_item, tmp_path):
+        """Test ALTO XML contains Layout section."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        alto_xml = generator.generate_alto_xml()
+
+        namespaces = {'alto': ALTOGenerator.ALTO_NAMESPACE}
+        layout = alto_xml.find('alto:Layout', namespaces)
+        assert layout is not None
+
+    def test_alto_xml_has_pages(self, sample_ceo_item, tmp_path):
+        """Test ALTO XML contains Page elements."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        alto_xml = generator.generate_alto_xml()
+
+        namespaces = {'alto': ALTOGenerator.ALTO_NAMESPACE}
+        pages = alto_xml.findall('.//alto:Page', namespaces)
+        assert len(pages) > 0
+
+    def test_alto_xml_page_attributes(self, sample_ceo_item, tmp_path):
+        """Test Page elements have required attributes."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        alto_xml = generator.generate_alto_xml()
+
+        namespaces = {'alto': ALTOGenerator.ALTO_NAMESPACE}
+        page = alto_xml.find('.//alto:Page', namespaces)
+
+        assert page is not None
+        assert 'ID' in page.attrib
+        assert 'HEIGHT' in page.attrib
+        assert 'WIDTH' in page.attrib
+        assert 'PHYSICAL_IMG_NR' in page.attrib
+
+    def test_alto_generator_to_string(self, sample_ceo_item, tmp_path):
+        """Test generating ALTO XML as string."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        xml_string = generator.to_string()
+
+        assert isinstance(xml_string, str)
+        assert "alto" in xml_string
+        assert "Layout" in xml_string
+
+    def test_alto_generator_to_string_pretty_print(self, sample_ceo_item, tmp_path):
+        """Test generating formatted ALTO XML string."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        xml_string = generator.to_string(pretty_print=True)
+
+        assert isinstance(xml_string, str)
+        # Pretty printed XML should have newlines
+        assert '\n' in xml_string
+
+    def test_alto_generator_generate_file(self, sample_ceo_item, tmp_path):
+        """Test generating ALTO XML file."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        alto_path = tmp_path / "test.alto.xml"
+        generator.generate(alto_path)
+
+        assert alto_path.exists()
+        assert alto_path.stat().st_size > 0
+
+    def test_alto_generated_file_is_valid_xml(self, sample_ceo_item, tmp_path):
+        """Test generated ALTO file is valid XML."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        alto_path = tmp_path / "test.alto.xml"
+        generator.generate(alto_path)
+
+        # Parse the file to ensure it's valid XML
+        tree = etree.parse(str(alto_path))
+        root = tree.getroot()
+        assert root is not None
+
+    def test_alto_file_has_correct_namespace(self, sample_ceo_item, tmp_path):
+        """Test generated ALTO file has correct namespace."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        alto_path = tmp_path / "test.alto.xml"
+        generator.generate(alto_path)
+
+        tree = etree.parse(str(alto_path))
+        root = tree.getroot()
+        assert ALTOGenerator.ALTO_NAMESPACE in root.tag
+
+    def test_alto_file_creates_parent_directories(self, sample_ceo_item, tmp_path):
+        """Test that generate() creates parent directories if needed."""
+        html_gen = HTMLGenerator(sample_ceo_item)
+        pdf_path = tmp_path / "test.pdf"
+        pdf_gen = PDFGenerator(html_gen.html)
+        pdf_gen.generate(pdf_path)
+
+        generator = ALTOGenerator(pdf_path)
+        alto_path = tmp_path / "nested" / "dir" / "test.alto.xml"
+        generator.generate(alto_path)
+
+        assert alto_path.exists()
+        assert alto_path.parent.exists()
-- 
2.43.0

